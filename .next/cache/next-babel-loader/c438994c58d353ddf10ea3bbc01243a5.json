{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport const AUTH_ME = 'AUTH_ME';\nexport const AUTH_ME_CLEAN = 'AUTH_ME_CLEAN';\nexport const AUTH_ME_SUCCESS = 'AUTH_ME_SUCCESS';\nexport const AUTH_ME_FAILURE = 'AUTH_ME_FAILURE';\nconst INITIAL_STATE = {\n  refresh: {\n    accessToken: '',\n    expiresIn: 0\n  },\n  error: {\n    message: ''\n  },\n  isAuthenticated: false,\n  isError: false,\n  isLoading: false,\n  me: {\n    auth: {},\n    detail: {},\n    provider: [],\n    user: {}\n  }\n};\n\nconst Auth = (state = INITIAL_STATE, {\n  type,\n  payload\n}) => {\n  switch (type) {\n    case AUTH_ME:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: true\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport function authMe() {\n  return {\n    type: AUTH_ME\n  };\n}\nexport default Auth;","map":{"version":3,"sources":["/Users/muhilham/Documents/repo/getCraft/fe-test/redux/ducks/PhoneBook.js"],"names":["AUTH_ME","AUTH_ME_CLEAN","AUTH_ME_SUCCESS","AUTH_ME_FAILURE","INITIAL_STATE","refresh","accessToken","expiresIn","error","message","isAuthenticated","isError","isLoading","me","auth","detail","provider","user","Auth","state","type","payload","authMe"],"mappings":";;;;;;AAAA,OAAO,MAAMA,OAAO,GAAG,SAAhB;AACP,OAAO,MAAMC,aAAa,GAAG,eAAtB;AACP,OAAO,MAAMC,eAAe,GAAG,iBAAxB;AACP,OAAO,MAAMC,eAAe,GAAG,iBAAxB;AAEP,MAAMC,aAAa,GAAG;AACpBC,EAAAA,OAAO,EAAE;AACPC,IAAAA,WAAW,EAAE,EADN;AAEPC,IAAAA,SAAS,EAAE;AAFJ,GADW;AAKpBC,EAAAA,KAAK,EAAE;AACLC,IAAAA,OAAO,EAAE;AADJ,GALa;AAQpBC,EAAAA,eAAe,EAAE,KARG;AASpBC,EAAAA,OAAO,EAAE,KATW;AAUpBC,EAAAA,SAAS,EAAE,KAVS;AAWpBC,EAAAA,EAAE,EAAE;AACFC,IAAAA,IAAI,EAAE,EADJ;AAEFC,IAAAA,MAAM,EAAE,EAFN;AAGFC,IAAAA,QAAQ,EAAE,EAHR;AAIFC,IAAAA,IAAI,EAAE;AAJJ;AAXgB,CAAtB;;AAmBA,MAAMC,IAAI,GAAG,CAACC,KAAK,GAAGf,aAAT,EAAwB;AAAEgB,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAxB,KAA8C;AACzD,UAAQD,IAAR;AACA,SAAKpB,OAAL;AACE,6CACKmB,KADL;AAEEP,QAAAA,SAAS,EAAE;AAFb;;AAKF;AACE,aAAOO,KAAP;AARF;AAUD,CAXD;;AAaA,OAAO,SAASG,MAAT,GAAkB;AACvB,SAAO;AACLF,IAAAA,IAAI,EAAEpB;AADD,GAAP;AAGD;AAED,eAAekB,IAAf","sourcesContent":["export const AUTH_ME = 'AUTH_ME'\nexport const AUTH_ME_CLEAN = 'AUTH_ME_CLEAN'\nexport const AUTH_ME_SUCCESS = 'AUTH_ME_SUCCESS'\nexport const AUTH_ME_FAILURE = 'AUTH_ME_FAILURE'\n\nconst INITIAL_STATE = {\n  refresh: {\n    accessToken: '',\n    expiresIn: 0,\n  },\n  error: {\n    message: '',\n  },\n  isAuthenticated: false,\n  isError: false,\n  isLoading: false,\n  me: {\n    auth: {},\n    detail: {},\n    provider: [],\n    user: {},\n  },\n}\n\nconst Auth = (state = INITIAL_STATE, { type, payload }) => {\n  switch (type) {\n  case AUTH_ME:\n    return {\n      ...state,\n      isLoading: true,\n    }\n\n  default:\n    return state\n  }\n}\n\nexport function authMe() {\n  return {\n    type: AUTH_ME,\n  }\n}\n\nexport default Auth\n"]},"metadata":{},"sourceType":"module"}